[{"title":"way","date":"2017-04-19T08:33:06.000Z","path":"2017/04/19/way/","text":"我也是一个经历过柴米油盐酱醋茶、尝过酸甜苦辣咸的前端程序员。知道前端的东西入门简单，有深度却很难；表似好看无比的应用，其实背后逻辑复杂，然而要想成长的更快，一定要学会站在巨人的肩膀上，“学以师技以自长”。所以一些经验非常可贵，在此我想和大家分享一下我的经验。我是一个从jquery，zepto，到vue的比较常规的技术栈过渡过程。本文涉及面包括：jquer有处理模板的办法，高效处理json个数据，如何有效命名，如何搭建合适的web服务，如何做出高效的动画，vue组件处理的方式，同时覆盖如何使用github管理你的项目和文章 1、jQuery.js中的tmpl大法在当初没有vue、react等mvvm框架的时候，这些都是非常牛逼使用的东西12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot; /&gt; &lt;title&gt;jquery-tmpl&lt;/title&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;./jquery.min.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;./jquery.tmpl.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;style&gt; .left-box &#123; float: left; width: 50%; &#125; .right-box &#123; float: right; width: 50%; &#125; ul,li &#123; overflow: hidden; margin: 10px; width: 100%; &#125; &lt;/style&gt; &lt;body&gt; &lt;script type=&quot;text/x-jquery-tmpl&quot; id=&quot;reuse&quot;&gt; &lt;li&gt; &lt;div class=&quot;left-box&quot;&gt; &lt;p&gt;$&#123;name&#125;&lt;/p&gt; &lt;p&gt;$&#123;prize&#125;￥&lt;/p&gt; &lt;/div&gt; &lt;div class=&quot;right-box&quot;&gt;点击&lt;/div&gt; &lt;/li&gt; &lt;/script&gt; &lt;div&gt; &lt;ul id=&quot;list&quot;&gt; &lt;/ul&gt; &lt;/div&gt; &lt;/body&gt; &lt;script&gt; $(function() &#123; var list = [&#123;name:&quot;计算机科学&quot;,prize:11&#125;,&#123;name:&quot;JAVA&quot;,prize:55&#125;,&#123;name:&quot;CSS&quot;,prize:42&#125;] $( &quot;#reuse&quot; ).tmpl(list).appendTo(&quot;#list&quot; ); &#125;) &lt;/script&gt;&lt;/html&gt; 直接渲染上，堪比v-for；然而现在vue，angular框架可以替代jquery，同时开发效率高 2、小坑总结大法在处理json数据的时候多用原生方法toString()和split();来合并和分割数组，效率会高很多123456781.采用 text-align: justify; 实现段落对齐；2.采用 text-justify: inter-ideograph; 解决 IE 下中英混排问题；3.部分 webkit 浏览器在处理中英混排时会出现超过 1em 的间隙，可采用 word-break: break-all; 解决，但会导致行首行尾禁则失效。 p &#123; text-align: justify; text-justify: inter-ideograph; /* IE 私有，解决中英混排 */ word-break: break-all; /* For webkit */&#125; 链接地址 3、页面动效神器大法用添加或者取消class来控制动态效果最好，避免在js代码中有一系列样式问题；动画单一效果时：就用自带的移动translate、方法缩小scale、旋转rotate多种组合：cubic-bezier(0.500, 0.250, 0.500, 0.750)曲线 如何提高有效的动效反馈 动画参考地址：isux.tencent.com animation就够你用了 4、命名大法在做一个项目的时候，我们往往遭遇命名问题的困惑，当看到一些非专业人的代码，看到他们凌乱的码法，有时候真的苦不堪言。深刻知道一个良好的命名规范的重要性，同时在项目中也会遇到一些命名的瓶颈。所以有必要写一篇关于常见命名的方式。以下是通过3年的编程经验，以及参考网上知名的开源项目总结的一点经验。 1.文件夹命名 1.最好用一个单词描述 常用项目命名 omi、element、master、project、test、vue、iview 二级目录 build、static、config、src、examples、base、common、issues、assert 三级目录 libs、models、plugins、skins、images、css、js 2.如果一个单词描述不了，用2个词（名词加动词） color-pick、button-groups、date-picker、option-grounp、jquery-select、jquery-swiper 3.中间用-或者_连接为了方便归类、一目了然 node_models、async-demo、array-union、array-differ、babel-each。 2.文件命名 1.最好用一个单词描述 以下变量名可以加css、js、html，例如index.html、index.js、index.css。 常用组件命名 index、message、menu、slider（滑块）、page、progress（进度条）、tooltip（提示）、tree、upload、time、button、checkbox、dialog、cascader（三级联动） 常用文件命名 index、shopping（购物）、 share（分享）、integral（积分）、advertisement（广告）、pay（支付）、community（社区）、game、docs、bussiness 具体优化命名文章原文章 5、微信公众号开发大法基于微信开发，目前最火的是小程序和公众号开发，而我做的最多的是公众号开发,基础的有1、微信公众号 目的是进行授权 要是需要支付功能，则需开通微信支付。2、微信开发者工具 （1）目的是授权之后的网页无法在pc浏览器中浏览 （2）微信api需要在微信环境下生效，可以利用微信开发者工具跟踪你微信api的实现状况。3、需要一部手机、严格的说你需要两部手机。一部安卓、一部ios手机。目的是安卓手机里面微信用的是自己的qq浏览器、但是苹果手机是safari浏览器，因此兼容性你需要适配。主要说下卡券和支付的问题。有点长请点击地址12345![Paste_Image.png](https://user-gold-cdn.xitu.io/2017/4/17/0a769ba168157b96a319d9eea620dd18)开发请时刻打开葵花宝典微信开发者文档：http://mp.weixin.qq.com/wiki/home/![Paste_Image.png](https://user-gold-cdn.xitu.io/2017/4/17/67b5199573c297f5117c1f15739bc9c2)ok现在工具有了，可以开始讲开发阶段了。第一授权，微信授权分为静默授权和弹皮授权、目的就是获取用户信息、取得用户的唯一openid、以便业务的开发。 6、vue消息传递大法1、在vue1.0中组件消息传递子向父传递消息：this.$dispatch(&apos;on-change&apos;, this.checked); 父向子传递消息：this.$broadcast(&apos;on-change&apos;, this.checked); #### 2、在vue2中组件消息传递，已经去除$dispatch、$broadcast，官方推荐使用vuex或者全局的事件驱动； 防止子组件修改父组件的值已经去掉双向流动的特性sync。所以 父组件向子组件传递：props[] 子组件向父组件传递：$emit，this.$emit(&apos;on-change&apos;, this.checked); 7、vue避免某些生命周期只执行一遍问题在做vue项目的时候我们通常会写一些公共组件组件，而公共组件因为会频繁，考虑到效率问题肯定会采用v-show来控制显示隐藏；但是v-show的一些ready(mounted)方法会在编译时就已经执行了，所以当再次-v-show时发现ready(mounted)之前的方法不会执行;不要急通常会有两种办法。 1、用watch监听1234567891011121314151617181920watch: &#123; visible (val) &#123; if (val === false) &#123; this.buttonLoading = false; setTimeout(() =&gt; &#123; this.wrapShow = false; &#125;, 300); this.removeScrollEffect(); &#125; else &#123; this.wrapShow = true; this.addScrollEffect(); &#125; &#125;, loading (val) &#123; if (!val) &#123; this.buttonLoading = false; &#125; &#125; &#125; 这就是监听&apos;visible&apos;、`loading`这两个变量的值来重新执行`removeScrollEffect`和`addScrollEffect`方法。 2、用v-if强制结束生命周期123456&lt;template&gt; &lt;div v-if=&quot;!closed&quot; :class=&quot;classes&quot; transition=&quot;fade&quot;&gt; &lt;span :class=&quot;dotClasses&quot; v-if=&quot;showDot&quot;&gt;&lt;/span&gt;&lt;span :class=&quot;textClasses&quot;&gt;&lt;slot&gt;&lt;/slot&gt;&lt;/span&gt;&lt;Icon v-if=&quot;closable&quot; type=&quot;ios-close-empty&quot; @click=&quot;close&quot;&gt;&lt;/Icon&gt; &lt;/div&gt;&lt;/template&gt;这样对于公共组件效率并不高，所以适用于非公共组件 8、web服务器选择其实常用的tomcat、xampp和node搭建的web服务器环境、nginx。 tomcat服务器：这个14年以前的web开发者，几乎再熟悉不过了。注意把静态文件放到webapps里面，启动后就可以访问。缺点缓存太严重，每次需要清除缓存。 xampp：主要是针对php工程师的，不过前端访问代码也很方便，只需要配置一下第一，打开httpd.conf文件。其位置位于XAMPP安装目录下面的“apache\\conf”文件夹里。第二，修改代码。在httpd.conf文件中找到如下两行代码，并进行修改。123456(根目录）DocumentRoot “C:/xampp/htdocs”&lt;Directory “C:/xampp/htdocs”&gt;将两个目录更改为你所希望的目录即可，如我修改如下：（C:/Web为我本人新的网址根目录）DocumentRoot “D:/Webs”&lt;Directory “D:/Web”&gt; 可以方便的指定目录; node搭建服务器环境（源码） 利用express来搭建服务 npm install -g express 1npm install -g express 建立项目 123express project``` * 建立项目并install,执行npm start cd project,npm install,npm start1* 安装ejs修改解析的模板 npm install ejs修改app文件把jade修改成html解析模板var ejs = require(‘ejs’); app.engine(‘html’, ejs.__express);app.set(‘view engine’, ‘html’);123456 * 把你的代码放到views里面，启动浏览器访问：http://localhost:3000/![Paste_Image.png](https://user-gold-cdn.xitu.io/2017/4/17/8fa5921e763150ac95eade6382a6f372)* nginxnginx的功能不说了，最主要是反向代理，防止并发。运用场合是，多人合作，连接不同的服务请求，如果当web服务使用配置如下： server { listen 9006;#登录配置访问地址 server_name localhost; index index.html index.htm index.php; autoindex on; ssi on; limit_rate 2000k; client_max_body_size 2048m; location ~* .*\\.(html|htm|gif|jpg|jpeg|bmp|png|ico|txt|js|css|exe|map|json)$ { root D:/resource/public; # index index.html index.htm; } location ^~ /test/ { proxy_pass http://192.168.60.10:8181/test/; proxy_redirect default; proxy_cookie_path / / /; proxy_set_header Host $host:$server_port; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-Host $host:$server_port; proxy_set_header X-Forwarded-Server $host:$server_port; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; } } 12345其中(html|htm|gif|jpg|jpeg|bmp|png|ico|txt|js|css|exe|map|json)静态文件在本地读取,其他例如接口则在 http://192.168.60.10:8181/test/这个服务中读取，想大项目开发非常方便## 9、vuex使用大法vuex主要是利用状态管理机制，来解决VUE中复杂项目频繁组件通信，以及平行同行的问题，vue2.0推荐使用。vuex比window可以当全局变量的功能用，但是其优势是定义的数据更有模块性和追踪性。 1、编写store对象 define([], function() { var Vue = require(‘vue’) var Vuex = require(‘src/libs/vuex/vuex.js’) Vue.use(Vuex) var modelA= require(‘src/libs/vuex/modelA.js’) // 应用初始状态 var state = { count: 2 } // 定义所需的 mutations var mutations = { INCREMENT: function(state) { state.count++ }, DECREMENT: function(state) { state.count-- } } //这一块可以引入模块对象 var store = new Vuex.Store({ state: state, mutations: mutations, modules: { test: modelA } }) // 创建 store 实例 return store})```vuex参考实例 10、github博客和日志大法其实在开发的时候难免会遇到许多问题，许多坑，然而你如果自己从坑里爬起来了，肯定有很多感受。那么如果你想把这些感受写下来更好，如果不想写下来建议你写下来，分享便会成长。其中可以通过以下几种方式来完善你的博客和日志 github中readme 例如UI设计的想法你可以放资源，放笔记 github中issue 例如关于美学的思考你可以做笔记，写文章 github中wiki 例如关于美学的思考你可以做笔记，写文章,有目录，美观大方","tags":[{"name":"前端","slug":"前端","permalink":"https://holidaying.github.io/tags/前端/"},{"name":"js","slug":"js","permalink":"https://holidaying.github.io/tags/js/"},{"name":"css","slug":"css","permalink":"https://holidaying.github.io/tags/css/"},{"name":"html","slug":"html","permalink":"https://holidaying.github.io/tags/html/"},{"name":"vuex","slug":"vuex","permalink":"https://holidaying.github.io/tags/vuex/"},{"name":"实践","slug":"实践","permalink":"https://holidaying.github.io/tags/实践/"}]},{"title":"16个demo，webpack+react搭配使用","date":"2017-04-12T06:59:02.000Z","path":"2017/04/12/webpack/","text":"16个demo，webpack+react搭配使用首先教大家2个新技能 1.按照正常github地址情况下，你的github本身不能访问目录。 例如要访问vue-demo下的vueCpu文件夹:https://github.com/holidaying/vue-demo/vueCpu（显示404）但是在目录上加上tree/master/：https://github.com/holidaying/vue-demo/tree/master/vueCpu （master是分支名）就可以访问。 2.github目录的制作 明确一个问题。一个标题就是一个目录名称 写法[xx](#题目名称)#不能少 题目名称的写法规则：abc_demo-&gt; abc-demo,Abc-Demo-&gt;abc-demo。即就是题目中所有可见字符空格，以及其他字符均用-连接，并且全为小写 步骤首先，install Webpack 和 webpack-dev-server. 1$ npm i -g webpack webpack-dev-server 12345678# Linux &amp; Mac$ git clone git@github.com:holidaying/webpack-demos.git# Windows$ git clone https://github.com/holidaying/webpack-demos.git:$ cd webpack-demos$ npm install 接下来就可以进行demo演示了. 12$ cd demo01$ webpack-dev-server 用浏览器访问 http://127.0.0.1:8080. 什么是webpack？Webpack 是前端的打包工具类类似于 Grunt and Gulp.但是有区别，因为它是模块化构建机制，Webpack可以看做是模块打包机：它做的事情是，分析你的项目结构，找到JavaScript模块以及其它的一些浏览器不能直接运行的拓展语言（Scss，TypeScript等），并将其打包为合适的格式以供浏览器使用。WebPack和Grunt以及Gulp相比有什么特性其实Webpack和另外两个并没有太多的可比性，Gulp/Grunt是一种能够优化前端的开发流程的工具，而WebPack是一种模块化的解决方案，不过Webpack的优点使得Webpack可以替代Gulp/Grunt类的工具。Grunt和Gulp的工作方式是：在一个配置文件中，指明对某些文件进行类似编译，组合，压缩等任务的具体步骤，这个工具之后可以自动替你完成这些任务。更多信息.12$ webpack main.js bundle.js 它的配置文件是 webpack.config.js. 1234567// webpack.config.jsmodule.exports = &#123; entry: './main.js', output: &#123; filename: 'bundle.js' &#125;&#125;; 有了webpack.config.js,你可以不带参数使用webpack 1$ webpack 一些命令行选项你应该知道。 webpack – 构建文件 webpack -p – 发布 webpack --watch – 监听项目 webpack -d – 包含 source maps方便调试 webpack --colors – 让打包界面更好看 去构建你的项目, 你可以把启动项写进package.json 123456789// package.json&#123; // ... \"scripts\": &#123; \"dev\": \"webpack-dev-server --devtool eval --progress --colors\", \"deploy\": \"NODE_ENV=production webpack -p\" &#125;, // ...&#125; 目录 单文件入口 多文件入口 Babel-loader CSS-loader Image loader CSS Module UglifyJs Plugin插件 HTML Webpack Plugin and Open Browser Webpack Plugin Environment flags环境变量 Code splitting代码分割 Code splitting with bundle-loader Common chunk提取公共文件 Vendor chunk提取公共的第三方代码 externals全局变量 热模块替代/热更新 React router Demo01: 单文件入口 (源码)Webpack会入口文件进行打包成bundle.js. 例子, main.js 是单文件入口. 12// main.jsdocument.write('&lt;h1&gt;Hello World&lt;/h1&gt;'); index.html 12345&lt;html&gt; &lt;body&gt; &lt;script type=\"text/javascript\" src=\"bundle.js\"&gt;&lt;/script&gt; &lt;/body&gt;&lt;/html&gt; Webpack follows webpack.config.js to build bundle.js. 1234567// webpack.config.jsmodule.exports = &#123; entry: './main.js', output: &#123; filename: 'bundle.js' &#125;&#125;; 启动服务, 访问 http://127.0.0.1:8080 . 1$ webpack-dev-server Demo02: 多文件入口(源码)多个入口文件，实用于多个页面的应用 12345// main1.jsdocument.write('&lt;h1&gt;Hello World&lt;/h1&gt;');// main2.jsdocument.write('&lt;h2&gt;Hello Webpack&lt;/h2&gt;'); index.html 123456&lt;html&gt; &lt;body&gt; &lt;script src=\"bundle1.js\"&gt;&lt;/script&gt; &lt;script src=\"bundle2.js\"&gt;&lt;/script&gt; &lt;/body&gt;&lt;/html&gt; webpack.config.js 123456789module.exports = &#123; entry: &#123; bundle1: './main1.js', bundle2: './main2.js' &#125;, output: &#123; filename: '[name].js' &#125;&#125;; Demo03: Babel-loader (源码)通过使用不同的loader，webpack通过调用外部的脚本或工具可以对各种各样的格式的文件进行处理(更多信息). 例如, Babel-loader Babel其实是一个编译JavaScript的平台可以将 JSX/ES6 文件转换成浏览器可以识别的js文件. 官方文档loaders. main.jsx is a JSX 文件. 1234567const React = require('react');const ReactDOM = require('react-dom');ReactDOM.render( &lt;h1&gt;Hello, world!&lt;/h1&gt;, document.querySelector('#wrapper')); index.html 123456&lt;html&gt; &lt;body&gt; &lt;div id=\"wrapper\"&gt;&lt;/div&gt; &lt;script src=\"bundle.js\"&gt;&lt;/script&gt; &lt;/body&gt;&lt;/html&gt; webpack.config.js 123456789101112131415module.exports = &#123; entry: './main.jsx', output: &#123; filename: 'bundle.js' &#125;, module: &#123; loaders:[ &#123; test: /\\.js[x]?$/, exclude: /node_modules/, loader: 'babel-loader?presets[]=es2015&amp;presets[]=react' &#125;, ] &#125;&#125;; 在 webpack.config.js, module.loaders 区域是用来分配loader的. 像上面的代码片段使用了 babel-loader 需要安装插件 babel-preset-es2015 和 babel-preset-react to 编译成 ES6 and React. 可以用query配置参数 123456789101112module: &#123; loaders: [ &#123; test: /\\.jsx?$/, exclude: /node_modules/, loader: 'babel', query: &#123; presets: ['es2015', 'react'] &#125; &#125; ]&#125; Demo04: CSS-loader (源码)Webpack 允许你在js文件中require CSS , 通过 CSS-loader来预处理css文件. main.js 1require('./app.css'); app.css 123body &#123; background-color: blue;&#125; index.html 12345678&lt;html&gt; &lt;head&gt; &lt;script type=\"text/javascript\" src=\"bundle.js\"&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;Hello World&lt;/h1&gt; &lt;/body&gt;&lt;/html&gt; webpack.config.js 1234567891011module.exports = &#123; entry: './main.js', output: &#123; filename: 'bundle.js' &#125;, module: &#123; loaders:[ &#123; test: /\\.css$/, loader: 'style-loader!css-loader' &#125;, ] &#125;&#125;; 但是,你需要使用2中loaders来转换CSS 文件. 第一个是 CSS-loader 来读取CSS文件, 另外一个是Style-loader 是将style样式插入到html中。 中间用！连接 启动服务后, index.html 有内部样式. 12345678&lt;head&gt; &lt;script type=\"text/javascript\" src=\"bundle.js\"&gt;&lt;/script&gt; &lt;style type=\"text/css\"&gt; body &#123; background-color: blue; &#125; &lt;/style&gt;&lt;/head&gt; Demo05: Image loader (源码)Webpack 允许你在js文件中require图片 , 通过 url-loader和file-loader来预处理图片文件. main.js 1234567var img1 = document.createElement(\"img\");img1.src = require(\"./small.png\");document.body.appendChild(img1);var img2 = document.createElement(\"img\");img2.src = require(\"./big.png\");document.body.appendChild(img2); index.html 12345&lt;html&gt; &lt;body&gt; &lt;script type=\"text/javascript\" src=\"bundle.js\"&gt;&lt;/script&gt; &lt;/body&gt;&lt;/html&gt; webpack.config.js 1234567891011module.exports = &#123; entry: './main.js', output: &#123; filename: 'bundle.js' &#125;, module: &#123; loaders:[ &#123; test: /\\.(png|jpg)$/, loader: 'url-loader?limit=8192' &#125; ] &#125;&#125;; url-loader 转换图片文件. 如果图片的大小小于 8192 bytes,它将会转成base64位的地址; 相反, 它就是普通地址.参数前是用？连接的 启动服务后, small.png and big.png 将会有一下的地址. 12&lt;img src=\"data:image/png;base64,iVBOR...uQmCC\"&gt;&lt;img src=\"4853ca667a2b8b8844eb2693ac1b2578.png\"&gt; Demo06: CSS Module (源码)css-loader?modules (the query parameter modules) enables the CSS Modules spec. CSS Module可以开启全局变量和局部变量，:global(…)表示全局变量，可以在全局中使用样式(更多信息) index.html 12345678&lt;html&gt;&lt;body&gt; &lt;h1 class=\"h1\"&gt;Hello World&lt;/h1&gt; &lt;h2 class=\"h2\"&gt;Hello Webpack&lt;/h2&gt; &lt;div id=\"example\"&gt;&lt;/div&gt; &lt;script src=\"./bundle.js\"&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; app.css 1234567.h1 &#123; color:red;&#125;:global(.h2) &#123; color: blue;&#125; main.jsx 1234567891011var React = require('react');var ReactDOM = require('react-dom');var style = require('./app.css');ReactDOM.render( &lt;div&gt; &lt;h1 className=&#123;style.h1&#125;&gt;Hello World&lt;/h1&gt; &lt;h2 className=\"h2\"&gt;Hello Webpack&lt;/h2&gt; &lt;/div&gt;, document.getElementById('example')); webpack.config.js 12345678910111213141516171819202122module.exports = &#123; entry: './main.jsx', output: &#123; filename: 'bundle.js' &#125;, module: &#123; loaders:[ &#123; test: /\\.js[x]?$/, exclude: /node_modules/, loader: 'babel-loader', query: &#123; presets: ['es2015', 'react'] &#125; &#125;, &#123; test: /\\.css$/, loader: 'style-loader!css-loader?modules' &#125; ] &#125;&#125;; 启动服务. 1$ webpack-dev-server 访问 http://127.0.0.1:8080 , 你将看到只有第二个 h1 是红的,因为它是局部, 同时 h2 是蓝色的, 因为是h2全局的. Demo07: UglifyJs Plugin (源码)Webpack 可以去掉本身附加的东西，优化代码 UglifyJs Plugin will minify output(bundle.js) JS codes. main.js 123var longVariableName = 'Hello';longVariableName += ' World';document.write('&lt;h1&gt;' + longVariableName + '&lt;/h1&gt;'); index.html 12345&lt;html&gt;&lt;body&gt; &lt;script src=\"bundle.js\"&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; webpack.config.js 123456789101112131415var webpack = require('webpack');var uglifyJsPlugin = webpack.optimize.UglifyJsPlugin;module.exports = &#123; entry: './main.js', output: &#123; filename: 'bundle.js' &#125;, plugins: [ new uglifyJsPlugin(&#123; compress: &#123; warnings: false &#125; &#125;) ]&#125;; 启动服务后, main.js 将会压缩如下. 1var o=\"Hello\";o+=\" World\",document.write(\"&lt;h1&gt;\"+o+\"&lt;/h1&gt;\") Demo08: HTML Webpack Plugin and Open Browser Webpack Plugin (源码)这个例子需要加载三个插件 html-webpack-plugin 创建 index.html ，open-browser-webpack-plugin 打开浏览器 main.js 1document.write('&lt;h1&gt;Hello World&lt;/h1&gt;'); webpack.config.js 123456789101112131415161718var HtmlwebpackPlugin = require('html-webpack-plugin');var OpenBrowserPlugin = require('open-browser-webpack-plugin');module.exports = &#123; entry: './main.js', output: &#123; filename: 'bundle.js' &#125;, plugins: [ new HtmlwebpackPlugin(&#123; title: 'Webpack-demos', filename: 'index.html' &#125;), new OpenBrowserPlugin(&#123; url: 'http://localhost:8080' &#125;) ]&#125;; 启动 webpack-dev-server.启动这个需要node7版本以上1$ webpack-dev-server 不用手写index.html 也不用手动打开浏览器 Webpack 可以为你做这些事. Demo09: 设置环境变量(源码)你可以利用环境变量来控制特定代码的输出 main.js 12345document.write('&lt;h1&gt;Hello World&lt;/h1&gt;');if (__DEV__) &#123; document.write(new Date());&#125; index.html 12345&lt;html&gt;&lt;body&gt; &lt;script src=\"bundle.js\"&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; webpack.config.js 12345678910111213var webpack = require('webpack');var devFlagPlugin = new webpack.DefinePlugin(&#123; __DEV__: JSON.stringify(JSON.parse(process.env.DEBUG || 'false'))&#125;);module.exports = &#123; entry: './main.js', output: &#123; filename: 'bundle.js' &#125;, plugins: [devFlagPlugin]&#125;; 123456# Linux &amp; Mac$ env DEBUG=true webpack-dev-server# Windows$ set DEBUG=true$ webpack-dev-server Demo10: Code splitting (源码)对于大型项目，把所有代码编译到一个文件并不是有效的, Webpack 允许你把代码分成好多块. 特别是某种情况下，只需要个别代码这些块可以按需加载。在commonjs中有一个Modules/Async/A规范，里面定义了require.ensure语法。webpack实现了它，作用是可以在打包的时候进行代码分片，并异步加载分片后的代码。用法如下：require.ensure([], function(require){ var list = require(‘./list’); list.show();});此时list.js会被打包成一个单独的chunk文件，大概长这样：1.fb874860b35831bc96a8.js可读性比较差。我在上一篇结尾也提到了，给它命名的方式，那就是给require.ensure传递第三个参数，如： require.ensure([], function(require){ var list = require(‘./list’); list.show();}, ‘list’);这样就能得到你想要的文件名称：首先，你需要用 require.ensure to 来定义一个分割的点. (官方文档) 1234567// main.jsrequire.ensure(['./a'], function(require) &#123; var content = require('./a'); document.open(); document.write('&lt;h1&gt;' + content + '&lt;/h1&gt;'); document.close();&#125;); require.ensure 告诉 Webpack ./a.js 应该从 bundle.js 中分离成一个单独的块 12// a.jsmodule.exports = 'Hello World'; Now Webpack takes care of the dependencies, output files and runtime stuff. You don’t have to put any redundancy into your index.html and webpack.config.js. 12345&lt;html&gt; &lt;body&gt; &lt;script src=\"bundle.js\"&gt;&lt;/script&gt; &lt;/body&gt;&lt;/html&gt; webpack.config.js 123456module.exports = &#123; entry: './main.js', output: &#123; filename: 'bundle.js' &#125;&#125;; 地洞服务. 1$ webpack-dev-server 在界面上, 你感觉不到任何不一样的地方. 但是, Webpack 已经把 main.js 和 a.js 编译成(bundle.js 和 1.bundle.js)的块。 Demo11: 通过bundle-loader进行代码分裂 (源码)dem10是一种，另一种是利用bundle-loader. 123456789101112// main.js// Now a.js is requested, it will be bundled into another filevar load = require('bundle-loader!./a.js');// To wait until a.js is available (and get the exports)// you need to async wait for it.load(function(file) &#123; document.open(); document.write('&lt;h1&gt;' + file + '&lt;/h1&gt;'); document.close();&#125;); require(&#39;bundle-loader!./a.js&#39;) tells Webpack to load a.js from another chunk. Now Webpack will build main.js into bundle.js, and a.js into 1.bundle.js. Demo12: Common chunk (源码)利用webpack.optimize.CommonsChunkPlugin，你可以共通的组件，代码块分离出来 1234567891011121314151617// main1.jsxvar React = require('react');var ReactDOM = require('react-dom');ReactDOM.render( &lt;h1&gt;Hello World&lt;/h1&gt;, document.getElementById('a'));// main2.jsxvar React = require('react');var ReactDOM = require('react-dom');ReactDOM.render( &lt;h2&gt;Hello Webpack&lt;/h2&gt;, document.getElementById('b')); index.html 123456789&lt;html&gt; &lt;body&gt; &lt;div id=\"a\"&gt;&lt;/div&gt; &lt;div id=\"b\"&gt;&lt;/div&gt; &lt;script src=\"init.js\"&gt;&lt;/script&gt; &lt;script src=\"bundle1.js\"&gt;&lt;/script&gt; &lt;script src=\"bundle2.js\"&gt;&lt;/script&gt; &lt;/body&gt;&lt;/html&gt; webpack.config.js 12345678910111213141516171819202122232425var CommonsChunkPlugin = require(\"webpack/lib/optimize/CommonsChunkPlugin\");module.exports = &#123; entry: &#123; bundle1: './main1.jsx', bundle2: './main2.jsx' &#125;, output: &#123; filename: '[name].js' &#125;, module: &#123; loaders:[ &#123; test: /\\.js[x]?$/, exclude: /node_modules/, loader: 'babel-loader', query: &#123; presets: ['es2015', 'react'] &#125; &#125;, ] &#125;, plugins: [ new CommonsChunkPlugin('init.js') ]&#125; Demo13: Vendor chunk (源码)利用ebpack.optimize.CommonsChunkPlugin，你可以把第三方库抽离出来 main.js 12var $ = require('jquery');$('h1').text('Hello World'); index.html 1234567&lt;html&gt; &lt;body&gt; &lt;h1&gt;&lt;/h1&gt; &lt;script src=\"vendor.js\"&gt;&lt;/script&gt; &lt;script src=\"bundle.js\"&gt;&lt;/script&gt; &lt;/body&gt;&lt;/html&gt; webpack.config.js 1234567891011121314var webpack = require('webpack');module.exports = &#123; entry: &#123; app: './main.js', vendor: ['jquery'], &#125;, output: &#123; filename: 'bundle.js' &#125;, plugins: [ new webpack.optimize.CommonsChunkPlugin(/* chunkName= */'vendor', /* filename= */'vendor.js') ]&#125;; If you want a module available as variable in every module, such as making $ and jQuery available in every module without writing require(&quot;jquery&quot;). You should use ProvidePlugin (官方文档). 12345678910111213141516171819202122// main.js$('h1').text('Hello World');// webpack.config.jsvar webpack = require('webpack');module.exports = &#123; entry: &#123; app: './main.js' &#125;, output: &#123; filename: 'bundle.js' &#125;, plugins: [ new webpack.ProvidePlugin(&#123; $: \"jquery\", jQuery: \"jquery\", \"window.jQuery\": \"jquery\" &#125;) ]&#125;; 插件会执行两次这个方法，第一次将公共的第三方代码抽离移到vendor的块中，这个过程之前也讲过会将运行时runtime也转移到vendor块中，第二次执行则是将运行时runtime抽离出来转移到manifest块中。这步操作解决了缓存问题。这样处理，最后会生成3个打包文件chunk，app.js是业务代码，vendor则是公共的第三方代码，manifest.js则是运行时。 Demo14: Exposing global variables (源码)webpack可以不处理应用的某些依赖库，使用externals配置后，依旧可以在代码中通过CMD、AMD或者window/global全局的方式访问。如果你想引入一些全局变量, 但是不想被加载处理, 你可以在 webpack.config.js 使用 externals 模块 (官方文档).有时我们希望我们通过script引入的库，如用CDN的方式引入的jquery，我们在使用时，依旧用require的方式来使用，但是却不希望webpack将它又编译进文件中。 例子, data.js. 1var data = 'Hello World'; We can expose data as a global variable. 123456789101112131415161718192021222324// webpack.config.jsmodule.exports = &#123; entry: './main.jsx', output: &#123; filename: 'bundle.js' &#125;, module: &#123; loaders:[ &#123; test: /\\.js[x]?$/, exclude: /node_modules/, loader: 'babel-loader', query: &#123; presets: ['es2015', 'react'] &#125; &#125;, ] &#125;, externals: &#123; // require('data') is external and available // on the global var data 'data': 'data' &#125;&#125;; 现在, 你可以require data 作为模块化引入进来使用. 但是实际上是一个全局变量 123456789// main.jsxvar data = require('data');var React = require('react');var ReactDOM = require('react-dom');ReactDOM.render( &lt;h1&gt;&#123;data&#125;&lt;/h1&gt;, document.body); Demo15: 热模块替换/热更新 (源码)Hot Module Replacement (HMR) exchanges, adds, or removes modules while an application is running without a page reload. 通过webpack-dev-server.你可以使用2中方式 来进行热模块替换 (1) Specify --hot and --inline on the command line 1$ webpack-dev-server --hot --inline 参数的意思: --hot: adds the HotModuleReplacementPlugin and switch the server to hot mode. --inline: embed the webpack-dev-server runtime into the bundle. --hot --inline: also adds the webpack/hot/dev-server entry. (2) 修改 webpack.config.js. 添加 new webpack.HotModuleReplacementPlugin() to the plugins 模块 添加 webpack/hot/dev-server 和 webpack-dev-server/client?http://localhost:8080 to the entry 模块 webpack.config.js 如下所示. 12345678910111213141516171819202122232425262728var webpack = require('webpack');var path = require('path');module.exports = &#123; entry: [ 'webpack/hot/dev-server', 'webpack-dev-server/client?http://localhost:8080', './index.js' ], output: &#123; filename: 'bundle.js', publicPath: '/static/' &#125;, plugins: [ new webpack.HotModuleReplacementPlugin() ], module: &#123; loaders: [&#123; test: /\\.jsx?$/, exclude: /node_modules/, loader: 'babel-loader', query: &#123; presets: ['es2015', 'react'] &#125;, include: path.join(__dirname, '.') &#125;] &#125;&#125;; 启动服务 1$ webpack-dev-server 访问 http://localhost:8080, 你可以在浏览器上看到 ‘Hello World’ . 不要关闭服务.打开终端找到 App.js, 同时修改 ‘Hello World’ 为 ‘Hello Webpack’. 保存后，你就可以在浏览器上看到数据更新了 App.js 123456789import React, &#123; Component &#125; from 'react';export default class App extends Component &#123; render() &#123; return ( &lt;h1&gt;Hello World&lt;/h1&gt; ); &#125;&#125; index.js 12345import React from 'react';import ReactDOM from 'react-dom';import App from './App';ReactDOM.render(&lt;App /&gt;, document.getElementById('root')); index.html 123456&lt;html&gt; &lt;body&gt; &lt;div id='root'&gt;&lt;/div&gt; &lt;script src=\"/static/bundle.js\"&gt;&lt;/script&gt; &lt;/body&gt;&lt;/html&gt; Demo16: React router例子 (源码)利用webpack做的例子 React-router‘s 官方例子. Let’s imagine a little app with a dashboard, inbox, and calendar. 12345678910111213141516171819+---------------------------------------------------------+| +---------+ +-------+ +--------+ || |Dashboard| | Inbox | |Calendar| Logged in as Jane || +---------+ +-------+ +--------+ |+---------------------------------------------------------+| || Dashboard || || || +---------------------+ +----------------------+ || | | | | || | + + | +---------&gt; | || | | | | | | || | | + | | +-------------&gt; | || | | | + | | | | || | | | | | | | | || +-+---+----+-----+----+ +----------------------+ || |+---------------------------------------------------------+ 1$ webpack-dev-server --history-api-fallback 参照文档 Webpack docs webpack-howto, by Pete Hunt Diving into Webpack, by Web Design Weekly Webpack and React is awesome, by Christian Alfoni Browserify vs Webpack, by Cory House React Webpack cookbook, by Christian Alfoni LicenseMIT","tags":[{"name":"webpack","slug":"webpack","permalink":"https://holidaying.github.io/tags/webpack/"}]},{"title":"vue-plugins","date":"2017-04-10T13:19:31.000Z","path":"2017/04/10/vue-plugins/","text":"1.开发步骤按照vue-cli步骤部署plugins项目12345678# 全局安装 vue-cli$ npm install --global vue-cli# 创建一个基于 webpack 模板的新项目$ vue init webpack my-project# 安装依赖，走你$ cd my-project$ npm install$ npm run dev 2.配置wwebpack.base.conf模块1234567891011121314151617181920resolve: &#123; extensions: [&apos;.js&apos;, &apos;.vue&apos;, &apos;.json&apos;], modules: [ resolve(&apos;src&apos;), resolve(&apos;node_modules&apos;) ], alias: &#123; &apos;vue$&apos;: &apos;vue/dist/vue.js&apos;, &apos;src&apos;: resolve(&apos;src&apos;), &apos;jquery&apos;: &quot;jquery/src/jquery&quot; &#125; &#125;, plugins: [ new webpack.ProvidePlugin(&#123; $: &quot;jquery&quot;, jQuery: &quot;jquery&quot;, jquery: &quot;jquery&quot;, &quot;window.jQuery&quot;: &quot;jquery&quot; &#125;), ], main.js导入filter和自定义插件posaComponents 12345import posaComponents from &apos;./posasrc/index&apos;import Filter from &apos;./posasrc/filter&apos;import jQuery from &quot;./posasrc/packages/jquery.min.js&quot;;//全局处理window.jQuery = window.$ = jQuery; 3.使用使用分档正在写 4.打包发布需要修改config中index的1assetsPublicPath: &apos;./&apos;, 相对路径，否则github上显示404 5.注意babel配置babel需要配置present解析的版本，同时过滤node-modules访问地址访问地址构建包构建包","tags":[{"name":"vue插件","slug":"vue插件","permalink":"https://holidaying.github.io/tags/vue插件/"},{"name":"webpack","slug":"webpack","permalink":"https://holidaying.github.io/tags/webpack/"},{"name":"babel","slug":"babel","permalink":"https://holidaying.github.io/tags/babel/"}]},{"title":"git","date":"2017-03-23T06:08:29.000Z","path":"2017/03/23/git/","text":"要论版本控制工具，用的最多的是svn和Git。平时在项目工作中也用svn，对svn还算比较了解1.svn是集中版本管理一般给你一个svn地址，登陆用户名客户端，下载你所需要的项目。依赖于网络，没有网，你是不能commit和checkout2.SVN对中文支持好，操作简单，使用没有难度，美工人员，产品人员，测试人员，实施人员都可轻松上手。使用界面统一，功能完善，操作方便。3.有安全权限但是svn这么好用，为什么要用git呢？ 因为我们是程序员，需要git这样对代码管理方便的版本控制工具。 原因是你自己在本地有一个版本控制工具，可以不再联网的时候，查看log 所以作为一名有追求的高逼格程序员，我决定学习使用gitcsdn的博客搬不了，请看csdn博客","tags":[{"name":"git","slug":"git","permalink":"https://holidaying.github.io/tags/git/"}]},{"title":"async-demo","date":"2017-03-23T03:01:35.000Z","path":"2017/03/23/vue/","text":"async-demo关于一些处理异步请求的方法 1、常见的JavaScript场景 1.setInterval setTimeout这种计时器函数。 2.http请求例如vue-resource、fetch、axios。等请求方式。 2、常见的现象 1、不能按照要求得到结果 2、想要得到结果，需要运用传统的回调函数，表示非常的繁琐。123456789101112131415function A（）&#123; setTimeout(B(),200); C(); &#125;A()执行顺序A-&gt;B-&gt;Cvar c=&quot;&quot;;Vue.http.jsonp(&apos;http://ipinfo.io/json&apos;).then(function(data) &#123; self.weatherData.city = data.data.city; self.weatherData.country = data.data.country; c= data.data.city; &#125;);c=? 3、主要的方法 1、回调函数 1234567891011f1();f2();function f1(callback)&#123; setTimeout(function () &#123; // f1的任务代码 callback(); &#125;, 1000); &#125;f1(f2); 2、事件监听 12345678f1.on(&apos;done&apos;, f2);function f1()&#123; setTimeout(function () &#123; // f1的任务代码 f1.trigger(&apos;done&apos;); &#125;, 1000); &#125;f1(); 3、发布/订阅 123456789jQuery.subscribe(&quot;done&quot;, f2);function f1()&#123; setTimeout(function () &#123; // f1的任务代码 jQuery.publish(&quot;done&quot;); &#125;, 1000);&#125;f1();jQuery.unsubscribe(&quot;done&quot;, f2); 4、Promises对象 12345678910f1().then(f2);function f1()&#123; var dfd = $.Deferred(); setTimeout(function () &#123; // f1的任务代码 dfd.resolve(); &#125;, 500); return dfd.promise; &#125;f1(); 前面四种都是比较传统，同时还依赖jQuery，用的时候扩展性和方便都不带劲具体代码请查看这里，建议使用以下3中方式。 5、ES6 promise 6、ES6 generator 7、ES7 async和wait 4、实战项目 1、Promise123456789101112131415161718192021var promise = null;//定义全局变量//new 一个Promise对象promise = new Promise(function(resolve, reject) &#123; Vue.http.jsonp(&apos;http://ipinfo.io/json&apos;).then(function(data) &#123; if (data != null) &#123; resolve(data); &#125; else &#123; reject(&quot;fail&quot;); &#125; self.weatherData.city = data.data.city; self.weatherData.country = data.data.country; &#125;); &#125;)//利用promise进行链式传递 promise.then(function(data) &#123; var city = data.data.city+data.data.country; Vue.http.jsonp(api + city + units + appid).then(function(data) &#123; that.weatherShow(data); &#125;); &#125;) 总结 1、promise主要解决回调地狱问题 2、使得原本的多层级的嵌套代码，变成了链式调用 3、让代码更清晰，减少嵌套数 缺点：Promise 的最大问题是代码冗余，原来的任务被Promise 包装了一下，不管什么操作，一眼看去都是一堆 then，原来的语义变得很不清楚。demo 2、generator和yield123456789101112131415161718192021222324252627getLoc: function() &#123; var that = this; Vue.http.jsonp(&apos;http://ipinfo.io/json&apos;).then(function(data) &#123; self.weatherData.city = data.data.city; self.weatherData.country = data.data.country; it.next(data.data); //重点4 &#125;); &#125;, getCurrent: function(data) &#123; var that = this; var api = &quot;http://api.openweathermap.org/data/2.5/weather?q=&quot;; var units = &quot;&amp;units=metric&quot;; var appid = &quot;&amp;APPID=061f24cf3cde2f60644a8240302983f2&quot; var cb = &quot;&amp;callback=JSON_CALLBACK&quot;; var city = data.city + &apos;,&apos; + data.country; Vue.http.jsonp(api + city + units + appid).then(function(data) &#123; it.next(data);//重点4 &#125;);//重点1function* generator() &#123; var data = yield object.getLoc(); data = yield object.getCurrent(data); yield object.weatherShow(data); &#125; var it = generator();//重点2 it.next();//重点3 总结 1、利用迭代器原理，解决异步问题 2、让代码更清晰，减少嵌套数。 缺点：虽然Generator 函数将异步操作表示得很简洁，但是流程管理却不方便demo 3、async和wait 1234567891011121314151617181920212223242526272829303132getLoc: function() &#123; var that = this; return new Promise(function(resolve, reject) &#123; Vue.http.jsonp(&apos;http://ipinfo.io/json&apos;).then(function(data) &#123; self.weatherData.city = data.data.city; self.weatherData.country = data.data.country; resolve(data.data); &#125;); &#125;) &#125;, getCurrent: function(data) &#123; var that = this; var api = &quot;http://api.openweathermap.org/data/2.5/weather?q=&quot;; var units = &quot;&amp;units=metric&quot;; var appid = &quot;&amp;APPID=061f24cf3cde2f60644a8240302983f2&quot; var cb = &quot;&amp;callback=JSON_CALLBACK&quot;; var city = data.city + &apos;,&apos; + data.country; return new Promise(function(resolve, reject) &#123; Vue.http.jsonp(api + city + units + appid).then(function(data) &#123; resolve(data); // that.weatherShow(data); &#125;); &#125;); &#125;,//重点1 async function test() &#123; const v1 = await object.getLoc(); const v2 = await object.getCurrent(v1); const v3 = await object.weatherShow(v2); &#125; test(); 总结 1、解决异步问题 2、await后面不能再跟thunk函数，而必须跟一个Promise对象（因此，Promise才是异步的终极解决方案和未来）。跟其他类型的数据也OK，但是会直接同步执行，而不是异步。 3、让代码更清晰，减少嵌套数。 4、代码的易读性来将，async-await更加易读简介，也更加符合代码的语意。而且还不用引用第三方库，也无需学习Generator那一堆东西，使用成本非常低。demo 附上 github源代码 如果觉得好就关注吧","tags":[{"name":"前端","slug":"前端","permalink":"https://holidaying.github.io/tags/前端/"},{"name":"js","slug":"js","permalink":"https://holidaying.github.io/tags/js/"},{"name":"css","slug":"css","permalink":"https://holidaying.github.io/tags/css/"},{"name":"html","slug":"html","permalink":"https://holidaying.github.io/tags/html/"},{"name":"vuex","slug":"vuex","permalink":"https://holidaying.github.io/tags/vuex/"},{"name":"axios","slug":"axios","permalink":"https://holidaying.github.io/tags/axios/"}]},{"title":"如何高效的命名你的项目。","date":"2017-03-23T02:53:13.000Z","path":"2017/03/23/blog/","text":"如何高效的命名你的项目。在做一个项目的时候，我们往往遭遇命名问题的困惑，当看到一些非专业人的代码，看到他们凌乱的码法，有时候真的苦不堪言。深刻知道一个良好的命名规范的重要性，同时在项目中也会遇到一些命名的瓶颈。所以有必要写一篇关于常见命名的方式。以下是通过3年的编程经验，以及参考网上知名的开源项目总结的一点经验。希望共勉 1.文件夹命名 1.最好用一个单词描述 常用项目命名 omi、element、master、project、test、vue、iview 二级目录 build、static、config、src、examples、base、common、issues、assert 三级目录 libs、models、plugins、skins、images、css、js 2.如果一个单词描述不了，用2个词（名词加动词） color-pick、button-groups、date-picker、option-grounp、jquery-select、jquery-swiper 3.中间用-或者_连接为了方便归类、一目了然 node_models、async-demo、array-union、array-differ、babel-each。 2.文件命名 1.最好用一个单词描述 以下变量名可以加css、js、html，例如index.html、index.js、index.css。 常用组件命名 index、message、menu、slider（滑块）、page、progress（进度条）、tooltip（提示）、tree、upload、time、button、checkbox、dialog、cascader（三级联动） 常用文件命名 index、shopping（购物）、 share（分享）、integral（积分）、advertisement（广告）、pay（支付）、community（社区）、game、docs、bussiness 2.如果一个单词描述不了，用2个词（名词加动词） share-to-friends，share-to-community，weex-pay，alipay-pay，user-integral，game-page，docs-page等等反正就是自我想象。 3.中间用-或者_连接为了方便归类、一目了然 在目前做的pc端和移动端，简单的对他们分个类： 1.移动广告(mobile-advertisement) 2.移动社交(mobile-social) 3.移动电子商务(mobile-bussiness) 4.手机游戏(mobile-game) 5.手机电视(mobile-tv) 6.移动电子阅读(mobile-reading) 7.手机搜索(mobile-search) 8.移动支付(mobile-pay) 9.手机内容共享(mobile-share) 关于以上的项目都可以用名词+需要的动词命名，达到见词知意 3.html布局命名可以参考DIV+CSS规范命名大全集合但是我觉得写的并不是很好，很全面。因为往往比较纠结的是每一个大布局中小布局的命名。 外套 wrap #container 头部 header #head, #header，#nav，#sub-nav，#menu， #sub-menu，#branding 主要内容 main bussiness-title 、bussiness-logo、bussiness-search、bussiness-search-results 左侧 main-left #side-bar, #side-bar-a, #side-bar-b 右侧 main-right #side-bar, #side-bar-a, #side-bar-b 内容 content radio-click、radio-heightlight、radio-active、input-seach-off、input-search-on 底部 footer #service, #regsiter,#partner（合作伙伴）,#joinus, #site-info 总结 1.一般头部有nav、nav-event、nav-style、nav-item、nav-link。 2.内容：xx-title、xx-box、xx-warp、xx-item、xx-item-title、xx-item-link、xx-item-image 3.底部：footer-time、footer-box、footer-item、footer-item-link、footer-address。总之xx-wrap，xx-box，xx-item、xx-link、xx-title、xx-total肯定会满足你80%的需求 4.js变量命名 1.基础类型和引用数据类型 基础类型 字符串var s_count=””, 布尔类型var b_status=false, 数字类型var n_total=12。 引用数据类型 数组var ar_bar=[], 对象var o_bar={}, 函数var f_submit=function(){} 2.不要用关键字命名default、class、private 3.用可读的同义词代替保留词。 1234567891011121314// badvar superman = &#123; class: &apos;alien&apos;&#125;;// badvar superman = &#123; klass: &apos;alien&apos;&#125;;// goodvar superman = &#123; type: &apos;alien&apos;&#125;; 4.函数用驼峰形式（动词+名词） login(),logout(),expandList(),getTotal(),keySearch(),submitForm(),cancel(),goMore(),searchAll&gt;(),searchCurrent().clearContent().uploadImage().searchResult()这些都是常用事件，可以清晰知道每一项的意义。 5.当命名的构造函数和类使用PascalCase。 1234567891011121314151617// badfunction user(options) &#123; this.name = options.name;&#125;var bad = new user(&#123; name: &apos;nope&apos;&#125;);// goodfunction User(options) &#123; this.name = options.name;&#125;var good = new User(&#123; name: &apos;yup&apos;&#125;); 6.不要使用尾随或前导下划线。 1234567// badthis.__firstName__ = 'Panda';this.firstName_ = 'Panda';this._firstName = 'Panda';// goodthis.firstName = 'Panda'; 6.前缀jQuery对象变量与$。 12345678910111213141516171819202122232425262728293031323334353637383940414243// badvar sidebar = $(&apos;.sidebar&apos;);// goodvar $sidebar = $(&apos;.sidebar&apos;);// bad$(&apos;ul&apos;, &apos;.sidebar&apos;).hide();// badfunction setSidebar() &#123; $(&apos;.sidebar&apos;).hide(); // ...stuff... $(&apos;.sidebar&apos;).css(&#123; &apos;background-color&apos;: &apos;pink&apos; &#125;);&#125;// goodfunction setSidebar() &#123; var $sidebar = $(&apos;.sidebar&apos;); $sidebar.hide(); // ...stuff... $sidebar.css(&#123; &apos;background-color&apos;: &apos;pink&apos; &#125;);&#125;// bad$(&apos;.sidebar&apos;).find(&apos;ul&apos;).hide();// good$(&apos;.sidebar ul&apos;).hide();// good$(&apos;.sidebar &gt; ul&apos;).hide();// good$sidebar.find(&apos;ul&apos;).hide(); 5.css命名 公共的 common.css 其实和common差不多 base.css 动画 animation.css 皮肤 skin.css 文字 font.css 主题 themes.css 打印样式 print.css 颜色 color.css 6.图片命名 1、第一部分是图片的逻辑归属分类 2、第二部分是图片的表现内容 3、第三部分是图片的内容的类型（有些图片还会有第四部分，表示图片表现的状态。） 4、tabbar_home_icon, navigationbar_showtime_icon@2x.png，tabbar_categories_icon 7.分享demo 1.饿了么部分组织构架 2.腾讯omi es5的语法规范","tags":[{"name":"前端","slug":"前端","permalink":"https://holidaying.github.io/tags/前端/"},{"name":"js","slug":"js","permalink":"https://holidaying.github.io/tags/js/"},{"name":"css","slug":"css","permalink":"https://holidaying.github.io/tags/css/"},{"name":"html","slug":"html","permalink":"https://holidaying.github.io/tags/html/"}]},{"title":"svg","date":"2017-01-29T12:18:19.000Z","path":"2017/01/29/svg/","text":"SVG-demo一个不了解的svg的MDN学习之路 概念 可缩放矢量图形(svg),可缩放矢量图形是基于可扩展标记语言（标准通用标记语言的子集），用于描述二维矢量图形的一种图形格式。它由万维网联盟制定，是一个开放标准。2003年1月14日，成为W3C制定的标准。 SVG的优势 任意缩放 文本独立 较小文件 超强显示效果 超级颜色控制 交互强大 SVG的种类自从2003年成为W3C推荐标准以来，最接近的“完整版”SVG版本是1.1版，它基于1.0版，并且增加了更多便于实现的模块化内容，SVG1.1的第二个版本在2011年成为推荐标准，完整的SVG1.2本来是下一个标准版本，但它又被SVG2.0取代。SVG2.0正在制定当中，它采用了类似CSS3的制定方法，通过若干松散耦合的组件形成一套标准。 除了完整的SVG推荐标准，W3C工作组还在2003年推出了SVG Tiny和SVG Basic。这两个配置文件主要瞄准移动设备。首先SVG Tiny主要是为性能低的小设备生成图元，而SVG Basic实现了完整版SVG里的很多功能，只是舍弃了难以实现的大型渲染（比如动画）。2008年，SVG Tiny1.2成为W3C推荐标准。 另外还有一些关于SVG打印规格的项目，增加对多页面和颜色管理的支持，但是这项工作已经终止。 ##SVG学习之路 1.svg简单的例子(:apple:查看demo点这里)1234567891011&lt;svg version=&quot;1.1&quot; baseProfile=&quot;full&quot; width=&quot;300&quot; height=&quot;200&quot; xmlns=&quot;http://www.w3.org/2000/svg&quot;&gt; &lt;rect width=&quot;100%&quot; height=&quot;100%&quot; fill=&quot;red&quot; /&gt; &lt;circle cx=&quot;150&quot; cy=&quot;100&quot; r=&quot;80&quot; fill=&quot;green&quot; /&gt; &lt;text x=&quot;150&quot; y=&quot;125&quot; font-size=&quot;60&quot; text-anchor=&quot;middle&quot; fill=&quot;white&quot;&gt;SVG&lt;/text&gt;&lt;/svg&gt; 1.建立一个demo.svg文件，内容即为以上svg代码 2.配置nginx服务，指向本地环境 3.启动nginx 4.打开浏览器输入localhost:(端口号)/demo.svg。既能看到显示结果 5.分析：svg必须引入xmlns命名空间，同时确认其版本号 6.svg里面的元素有先后顺序，层级依次升高。2.svg的引入方式 1.直接嵌入html方式 2.用html节点引进来，但是必须指定type123456789&lt;object data=&quot;image.svg&quot; type=&quot;image/svg+xml&quot;&gt;&lt;/object&gt;embed data=&quot;image.svg&quot; type=&quot;image/svg+xml&quot;&gt;&lt;/embed&gt;&lt;iframe src=&quot;image.svg&quot;&gt;&lt;/iframe&gt;&lt;img src=&quot;image.svg&quot; alt=&quot;&quot;&gt;background:url(image.svg); 代码如下 显示结果 需要掌握的方面","tags":[{"name":"svg","slug":"svg","permalink":"https://holidaying.github.io/tags/svg/"}]},{"title":"vuex1.0你不知道的简单写法","date":"2016-12-10T13:55:25.000Z","path":"2016/12/10/vuex1-0/","text":"在一些小项目中其实可以不用vuex的，但是在一些大型项目中，vuex必然是必杀技，可以使你方便使用，方便跟踪视图的状态。1、编写store对象123456789101112131415161718192021222324252627282930define([], function() &#123; var Vue = require(&apos;vue&apos;) var Vuex = require(&apos;src/libs/vuex/vuex.js&apos;) Vue.use(Vuex) var modelA= require(&apos;src/libs/vuex/modelA.js&apos;) // 应用初始状态 var state = &#123; count: 2 &#125; // 定义所需的 mutations var mutations = &#123; INCREMENT: function(state) &#123; state.count++ &#125;, DECREMENT: function(state) &#123; state.count-- &#125; &#125;//这一块可以引入模块对象 var store = new Vuex.Store(&#123; state: state, mutations: mutations, modules: &#123; test: modelA &#125; &#125;) // 创建 store 实例 return store&#125;) 2、app中的vuex需要在启动的时候也就是vue-cli脚手架中的app.vue中把store注入大根目录，一次注入终身受用。如图用require引入store，并注入到vue的根组件。如果想要实现模块化状态控制，则参考以下3。3、modelA书写方式1234567891011121314151617define([], function() &#123; var modelA = &#123; state:&#123; name: 3 &#125;, // 定义所需的 mutations mutations:&#123; INCREMENT: function(state) &#123; state.name++ &#125;, DECREMENT: function(state) &#123; state.name-- &#125; &#125; &#125; return modelA;&#125;) 4、子组件中使用123456789101112131415161718vuex: &#123; getters: &#123; count: state =&gt; state.count//变量必须放这里，这里也可以是函数，当过滤器用 &#125;, actions: &#123; increment:function(dispatch)&#123; dispatch.dispatch(&apos;INCREMENT&apos;)//触发修改变量 &#125;, decrement:function(dispatch) &#123; dispatch.dispatch(&apos;DECREMENT&apos;) &#125; &#125; &#125;, created: function() &#123; &#125;,` 同时也可以这样用1234this.$store.dispatch(&apos;DECREMENT&apos;);//触发方法this.$store.commit(&apos;DECREMENT&apos;);//触发方法vuex2,在actions里面触发的方法this.$store.state.count=&apos;ssss&apos;;//修改变量的值this.$store.state.test.name=&apos;ssss&apos;;//修改模块变量的值 5、测试实例1、google浏览器的控制台 2.测试模块化变量 可以看出，dispatch会触发方法名相同的函数 相对来说，vuex比window定义的数据更有模块性和追踪性。有问题可以随时交流。","tags":[{"name":"vuex1.0","slug":"vuex1-0","permalink":"https://holidaying.github.io/tags/vuex1-0/"},{"name":"vuex使用方法","slug":"vuex使用方法","permalink":"https://holidaying.github.io/tags/vuex使用方法/"}]},{"title":"vue1.0项目经验","date":"2016-09-24T13:23:28.000Z","path":"2016/09/24/vue经验/","text":"进入公司差不多2个月了，这两个月内从vue的小白，变成现在可以完成一个模块，在这个过程中并不是一帆风顺，也遇到许多问题，但是通过自己的研究、查询，最终把他解决了。我觉得这些经验值得沉淀，值得总结分享一下。 1、vue核心vue是一个前段框架，“数据驱动的组件，为现代化的 Web 界面而生”，引用官网的一句话，正是因为数据绑定和组件化得分治的优势，在做项目的时候非常的方便。 2、vue组件布局 对项目的页面布局其实和普通的页面布局一样，像这类的页面布局就可以提供三个组件两个导航栏组件，一个主页面。 3、遍历操作对于选项卡点击变色,可以用vue自己提供的下表$index来控制样式，使用起来非常方便。 4、指令表达式对于显示不显示上的问题，可以在指令上编写逻辑表达式，用起来非常方便 5、某些函数未执行路由跳转的会重新编译，但是如果是同一个路由下页面的显示和隐藏也就是V-if和V-show只在显示的时候就编译一次，其余的便缓存起来，所以导致有些jquery组件只在第一编译成功，第二次便渲染不上值，解决办法是用watch来监听，非常的方便。 6、父子通信对于父子组件靠props通信的时候，父组件需要给组件上的属性附上默认值，否则，有时会警告报出，我们的项目上经常出现。 7、冒泡处理父子组件用broadcast和dispatch进行传递时，如果有出现链型情况，接受的事件如果一直向上冒泡，则需要在第一个接受后返回true 8、开发思想项目上为了减少耦合性，在css上多用组合少用继承。继承的方式很难存覆盖，用起来也不方便。 9、transition在vue动画上多用transition属性，比起dom的keyframe用起来更方便。 10、检查兼容性在html上多用语议性标签，提高seo处理能力，列表用ul li。图标的话i标签，段落p，小文字span。h5新特性的话可以在can i use上查看是否兼容 11、数组字符串建议用内置函数js方面，字符串拼接，可以先用数组push、然后用数组的自带方法toString()或者Join（）来拼接字符串，用起来非常方便。 12、vue警告有时候不想看到控制台vue的警告可以用vue.config.silent=true来控制 先分享这么多，遇到问题了，解决了再分享,如有需要请关注github账号","tags":[{"name":"vue","slug":"vue","permalink":"https://holidaying.github.io/tags/vue/"},{"name":"体会","slug":"体会","permalink":"https://holidaying.github.io/tags/体会/"}]}]